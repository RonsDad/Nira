"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/ui/flip-card-carousel/hooks/useThreeScene.ts":
/*!*********************************************************************!*\
  !*** ./src/components/ui/flip-card-carousel/hooks/useThreeScene.ts ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useThreeScene: () => (/* binding */ useThreeScene)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\n\nfunction useThreeScene(param) {\n    let { canvasRef, onResize } = param;\n    const sceneRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const rendererRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const cameraRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const frameIdRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const [isInitialized, setIsInitialized] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useThreeScene.useEffect\": ()=>{\n            if (!canvasRef.current) {\n                console.log('useThreeScene: No canvas ref');\n                return;\n            }\n            console.log('useThreeScene: Initializing scene');\n            // Scene setup\n            const scene = new three__WEBPACK_IMPORTED_MODULE_1__.Scene();\n            scene.background = new three__WEBPACK_IMPORTED_MODULE_1__.Color(0xffffff); // Pure white background\n            sceneRef.current = scene;\n            // Camera setup - simpler positioning\n            const camera = new three__WEBPACK_IMPORTED_MODULE_1__.PerspectiveCamera(50, canvasRef.current.clientWidth / canvasRef.current.clientHeight, 0.1, 1000);\n            camera.position.set(0, 0, 8);\n            camera.lookAt(0, 0, 0);\n            cameraRef.current = camera;\n            // Renderer setup\n            const renderer = new three__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderer({\n                canvas: canvasRef.current,\n                antialias: true,\n                alpha: false\n            });\n            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n            renderer.setSize(canvasRef.current.clientWidth, canvasRef.current.clientHeight);\n            rendererRef.current = renderer;\n            // Simple lighting\n            const ambientLight = new three__WEBPACK_IMPORTED_MODULE_1__.AmbientLight(0xffffff, 0.8);\n            scene.add(ambientLight);\n            const directionalLight = new three__WEBPACK_IMPORTED_MODULE_1__.DirectionalLight(0xffffff, 0.5);\n            directionalLight.position.set(5, 5, 5);\n            scene.add(directionalLight);\n            // Add a test cube to verify scene is working\n            const testGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.BoxGeometry(1, 1, 1);\n            const testMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial({\n                color: 0xff0000\n            });\n            const testCube = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(testGeometry, testMaterial);\n            testCube.position.set(0, -10, 0); // Hide it below view\n            scene.add(testCube);\n            // Resize handler\n            const handleResize = {\n                \"useThreeScene.useEffect.handleResize\": ()=>{\n                    if (!canvasRef.current || !camera || !renderer) return;\n                    const width = canvasRef.current.clientWidth;\n                    const height = canvasRef.current.clientHeight;\n                    camera.aspect = width / height;\n                    camera.updateProjectionMatrix();\n                    renderer.setSize(width, height);\n                    onResize === null || onResize === void 0 ? void 0 : onResize(width, height);\n                }\n            }[\"useThreeScene.useEffect.handleResize\"];\n            window.addEventListener('resize', handleResize);\n            // Animation loop\n            const animate = {\n                \"useThreeScene.useEffect.animate\": ()=>{\n                    frameIdRef.current = requestAnimationFrame(animate);\n                    renderer.render(scene, camera);\n                }\n            }[\"useThreeScene.useEffect.animate\"];\n            animate();\n            // Mark as initialized\n            setIsInitialized(true);\n            console.log('useThreeScene: Scene initialized');\n            return ({\n                \"useThreeScene.useEffect\": ()=>{\n                    window.removeEventListener('resize', handleResize);\n                    if (frameIdRef.current) {\n                        cancelAnimationFrame(frameIdRef.current);\n                    }\n                    renderer.dispose();\n                }\n            })[\"useThreeScene.useEffect\"];\n        }\n    }[\"useThreeScene.useEffect\"], [\n        canvasRef,\n        onResize\n    ]);\n    return {\n        scene: isInitialized ? sceneRef.current : null,\n        renderer: isInitialized ? rendererRef.current : null,\n        camera: isInitialized ? cameraRef.current : null\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL2ZsaXAtY2FyZC1jYXJvdXNlbC9ob29rcy91c2VUaHJlZVNjZW5lLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBb0Q7QUFDckI7QUFPeEIsU0FBU0ksY0FBYyxLQUE2QztRQUE3QyxFQUFFQyxTQUFTLEVBQUVDLFFBQVEsRUFBd0IsR0FBN0M7SUFDNUIsTUFBTUMsV0FBV04sNkNBQU1BLENBQXFCO0lBQzVDLE1BQU1PLGNBQWNQLDZDQUFNQSxDQUE2QjtJQUN2RCxNQUFNUSxZQUFZUiw2Q0FBTUEsQ0FBaUM7SUFDekQsTUFBTVMsYUFBYVQsNkNBQU1BO0lBQ3pCLE1BQU0sQ0FBQ1UsZUFBZUMsaUJBQWlCLEdBQUdWLCtDQUFRQSxDQUFDO0lBRW5ERixnREFBU0E7bUNBQUM7WUFDUixJQUFJLENBQUNLLFVBQVVRLE9BQU8sRUFBRTtnQkFDdEJDLFFBQVFDLEdBQUcsQ0FBQztnQkFDWjtZQUNGO1lBRUFELFFBQVFDLEdBQUcsQ0FBQztZQUVaLGNBQWM7WUFDZCxNQUFNQyxRQUFRLElBQUliLHdDQUFXO1lBQzdCYSxNQUFNRSxVQUFVLEdBQUcsSUFBSWYsd0NBQVcsQ0FBQyxXQUFXLHdCQUF3QjtZQUN0RUksU0FBU00sT0FBTyxHQUFHRztZQUVuQixxQ0FBcUM7WUFDckMsTUFBTUksU0FBUyxJQUFJakIsb0RBQXVCLENBQ3hDLElBQ0FFLFVBQVVRLE9BQU8sQ0FBQ1MsV0FBVyxHQUFHakIsVUFBVVEsT0FBTyxDQUFDVSxZQUFZLEVBQzlELEtBQ0E7WUFFRkgsT0FBT0ksUUFBUSxDQUFDQyxHQUFHLENBQUMsR0FBRyxHQUFHO1lBQzFCTCxPQUFPTSxNQUFNLENBQUMsR0FBRyxHQUFHO1lBQ3BCakIsVUFBVUksT0FBTyxHQUFHTztZQUVwQixpQkFBaUI7WUFDakIsTUFBTU8sV0FBVyxJQUFJeEIsZ0RBQW1CLENBQUM7Z0JBQ3ZDMEIsUUFBUXhCLFVBQVVRLE9BQU87Z0JBQ3pCaUIsV0FBVztnQkFDWEMsT0FBTztZQUNUO1lBQ0FKLFNBQVNLLGFBQWEsQ0FBQ0MsS0FBS0MsR0FBRyxDQUFDQyxPQUFPQyxnQkFBZ0IsRUFBRTtZQUN6RFQsU0FBU1UsT0FBTyxDQUFDaEMsVUFBVVEsT0FBTyxDQUFDUyxXQUFXLEVBQUVqQixVQUFVUSxPQUFPLENBQUNVLFlBQVk7WUFDOUVmLFlBQVlLLE9BQU8sR0FBR2M7WUFFdEIsa0JBQWtCO1lBQ2xCLE1BQU1XLGVBQWUsSUFBSW5DLCtDQUFrQixDQUFDLFVBQVU7WUFDdERhLE1BQU13QixHQUFHLENBQUNGO1lBRVYsTUFBTUcsbUJBQW1CLElBQUl0QyxtREFBc0IsQ0FBQyxVQUFVO1lBQzlEc0MsaUJBQWlCakIsUUFBUSxDQUFDQyxHQUFHLENBQUMsR0FBRyxHQUFHO1lBQ3BDVCxNQUFNd0IsR0FBRyxDQUFDQztZQUVWLDZDQUE2QztZQUM3QyxNQUFNRSxlQUFlLElBQUl4Qyw4Q0FBaUIsQ0FBQyxHQUFHLEdBQUc7WUFDakQsTUFBTTBDLGVBQWUsSUFBSTFDLG9EQUF1QixDQUFDO2dCQUFFNEMsT0FBTztZQUFTO1lBQ25FLE1BQU1DLFdBQVcsSUFBSTdDLHVDQUFVLENBQUN3QyxjQUFjRTtZQUM5Q0csU0FBU3hCLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUkscUJBQXFCO1lBQ3ZEVCxNQUFNd0IsR0FBRyxDQUFDUTtZQUVWLGlCQUFpQjtZQUNqQixNQUFNRTt3REFBZTtvQkFDbkIsSUFBSSxDQUFDN0MsVUFBVVEsT0FBTyxJQUFJLENBQUNPLFVBQVUsQ0FBQ08sVUFBVTtvQkFFaEQsTUFBTXdCLFFBQVE5QyxVQUFVUSxPQUFPLENBQUNTLFdBQVc7b0JBQzNDLE1BQU04QixTQUFTL0MsVUFBVVEsT0FBTyxDQUFDVSxZQUFZO29CQUU3Q0gsT0FBT2lDLE1BQU0sR0FBR0YsUUFBUUM7b0JBQ3hCaEMsT0FBT2tDLHNCQUFzQjtvQkFDN0IzQixTQUFTVSxPQUFPLENBQUNjLE9BQU9DO29CQUV4QjlDLHFCQUFBQSwrQkFBQUEsU0FBVzZDLE9BQU9DO2dCQUNwQjs7WUFFQWpCLE9BQU9vQixnQkFBZ0IsQ0FBQyxVQUFVTDtZQUVsQyxpQkFBaUI7WUFDakIsTUFBTU07bURBQVU7b0JBQ2Q5QyxXQUFXRyxPQUFPLEdBQUc0QyxzQkFBc0JEO29CQUMzQzdCLFNBQVMrQixNQUFNLENBQUMxQyxPQUFPSTtnQkFDekI7O1lBQ0FvQztZQUVBLHNCQUFzQjtZQUN0QjVDLGlCQUFpQjtZQUNqQkUsUUFBUUMsR0FBRyxDQUFDO1lBRVo7MkNBQU87b0JBQ0xvQixPQUFPd0IsbUJBQW1CLENBQUMsVUFBVVQ7b0JBQ3JDLElBQUl4QyxXQUFXRyxPQUFPLEVBQUU7d0JBQ3RCK0MscUJBQXFCbEQsV0FBV0csT0FBTztvQkFDekM7b0JBQ0FjLFNBQVNrQyxPQUFPO2dCQUNsQjs7UUFDRjtrQ0FBRztRQUFDeEQ7UUFBV0M7S0FBUztJQUV4QixPQUFPO1FBQ0xVLE9BQU9MLGdCQUFnQkosU0FBU00sT0FBTyxHQUFHO1FBQzFDYyxVQUFVaEIsZ0JBQWdCSCxZQUFZSyxPQUFPLEdBQUc7UUFDaERPLFFBQVFULGdCQUFnQkYsVUFBVUksT0FBTyxHQUFHO0lBQzlDO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy90aW1odW50ZXIvbmlyYS1haS1waWxvdC1ob21lL3NyYy9jb21wb25lbnRzL3VpL2ZsaXAtY2FyZC1jYXJvdXNlbC9ob29rcy91c2VUaHJlZVNjZW5lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcblxuaW50ZXJmYWNlIFVzZVRocmVlU2NlbmVPcHRpb25zIHtcbiAgY2FudmFzUmVmOiBSZWFjdC5SZWZPYmplY3Q8SFRNTENhbnZhc0VsZW1lbnQ+O1xuICBvblJlc2l6ZT86ICh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRocmVlU2NlbmUoeyBjYW52YXNSZWYsIG9uUmVzaXplIH06IFVzZVRocmVlU2NlbmVPcHRpb25zKSB7XG4gIGNvbnN0IHNjZW5lUmVmID0gdXNlUmVmPFRIUkVFLlNjZW5lIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IHJlbmRlcmVyUmVmID0gdXNlUmVmPFRIUkVFLldlYkdMUmVuZGVyZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgY2FtZXJhUmVmID0gdXNlUmVmPFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGZyYW1lSWRSZWYgPSB1c2VSZWY8bnVtYmVyPigpO1xuICBjb25zdCBbaXNJbml0aWFsaXplZCwgc2V0SXNJbml0aWFsaXplZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmxvZygndXNlVGhyZWVTY2VuZTogTm8gY2FudmFzIHJlZicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCd1c2VUaHJlZVNjZW5lOiBJbml0aWFsaXppbmcgc2NlbmUnKTtcblxuICAgIC8vIFNjZW5lIHNldHVwXG4gICAgY29uc3Qgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICBzY2VuZS5iYWNrZ3JvdW5kID0gbmV3IFRIUkVFLkNvbG9yKDB4ZmZmZmZmKTsgLy8gUHVyZSB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgc2NlbmVSZWYuY3VycmVudCA9IHNjZW5lO1xuXG4gICAgLy8gQ2FtZXJhIHNldHVwIC0gc2ltcGxlciBwb3NpdGlvbmluZ1xuICAgIGNvbnN0IGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYShcbiAgICAgIDUwLFxuICAgICAgY2FudmFzUmVmLmN1cnJlbnQuY2xpZW50V2lkdGggLyBjYW52YXNSZWYuY3VycmVudC5jbGllbnRIZWlnaHQsXG4gICAgICAwLjEsXG4gICAgICAxMDAwXG4gICAgKTtcbiAgICBjYW1lcmEucG9zaXRpb24uc2V0KDAsIDAsIDgpO1xuICAgIGNhbWVyYS5sb29rQXQoMCwgMCwgMCk7XG4gICAgY2FtZXJhUmVmLmN1cnJlbnQgPSBjYW1lcmE7XG5cbiAgICAvLyBSZW5kZXJlciBzZXR1cFxuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgICAgY2FudmFzOiBjYW52YXNSZWYuY3VycmVudCxcbiAgICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICAgIGFscGhhOiBmYWxzZSxcbiAgICB9KTtcbiAgICByZW5kZXJlci5zZXRQaXhlbFJhdGlvKE1hdGgubWluKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCAyKSk7XG4gICAgcmVuZGVyZXIuc2V0U2l6ZShjYW52YXNSZWYuY3VycmVudC5jbGllbnRXaWR0aCwgY2FudmFzUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0KTtcbiAgICByZW5kZXJlclJlZi5jdXJyZW50ID0gcmVuZGVyZXI7XG5cbiAgICAvLyBTaW1wbGUgbGlnaHRpbmdcbiAgICBjb25zdCBhbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KDB4ZmZmZmZmLCAwLjgpO1xuICAgIHNjZW5lLmFkZChhbWJpZW50TGlnaHQpO1xuXG4gICAgY29uc3QgZGlyZWN0aW9uYWxMaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAwLjUpO1xuICAgIGRpcmVjdGlvbmFsTGlnaHQucG9zaXRpb24uc2V0KDUsIDUsIDUpO1xuICAgIHNjZW5lLmFkZChkaXJlY3Rpb25hbExpZ2h0KTtcblxuICAgIC8vIEFkZCBhIHRlc3QgY3ViZSB0byB2ZXJpZnkgc2NlbmUgaXMgd29ya2luZ1xuICAgIGNvbnN0IHRlc3RHZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgxLCAxLCAxKTtcbiAgICBjb25zdCB0ZXN0TWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHhmZjAwMDAgfSk7XG4gICAgY29uc3QgdGVzdEN1YmUgPSBuZXcgVEhSRUUuTWVzaCh0ZXN0R2VvbWV0cnksIHRlc3RNYXRlcmlhbCk7XG4gICAgdGVzdEN1YmUucG9zaXRpb24uc2V0KDAsIC0xMCwgMCk7IC8vIEhpZGUgaXQgYmVsb3cgdmlld1xuICAgIHNjZW5lLmFkZCh0ZXN0Q3ViZSk7XG5cbiAgICAvLyBSZXNpemUgaGFuZGxlclxuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQgfHwgIWNhbWVyYSB8fCAhcmVuZGVyZXIpIHJldHVybjtcblxuICAgICAgY29uc3Qgd2lkdGggPSBjYW52YXNSZWYuY3VycmVudC5jbGllbnRXaWR0aDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhc1JlZi5jdXJyZW50LmNsaWVudEhlaWdodDtcblxuICAgICAgY2FtZXJhLmFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgIG9uUmVzaXplPy4od2lkdGgsIGhlaWdodCk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuXG4gICAgLy8gQW5pbWF0aW9uIGxvb3BcbiAgICBjb25zdCBhbmltYXRlID0gKCkgPT4ge1xuICAgICAgZnJhbWVJZFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgIH07XG4gICAgYW5pbWF0ZSgpO1xuXG4gICAgLy8gTWFyayBhcyBpbml0aWFsaXplZFxuICAgIHNldElzSW5pdGlhbGl6ZWQodHJ1ZSk7XG4gICAgY29uc29sZS5sb2coJ3VzZVRocmVlU2NlbmU6IFNjZW5lIGluaXRpYWxpemVkJyk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICBpZiAoZnJhbWVJZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgICByZW5kZXJlci5kaXNwb3NlKCk7XG4gICAgfTtcbiAgfSwgW2NhbnZhc1JlZiwgb25SZXNpemVdKTtcblxuICByZXR1cm4ge1xuICAgIHNjZW5lOiBpc0luaXRpYWxpemVkID8gc2NlbmVSZWYuY3VycmVudCA6IG51bGwsXG4gICAgcmVuZGVyZXI6IGlzSW5pdGlhbGl6ZWQgPyByZW5kZXJlclJlZi5jdXJyZW50IDogbnVsbCxcbiAgICBjYW1lcmE6IGlzSW5pdGlhbGl6ZWQgPyBjYW1lcmFSZWYuY3VycmVudCA6IG51bGwsXG4gIH07XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJUSFJFRSIsInVzZVRocmVlU2NlbmUiLCJjYW52YXNSZWYiLCJvblJlc2l6ZSIsInNjZW5lUmVmIiwicmVuZGVyZXJSZWYiLCJjYW1lcmFSZWYiLCJmcmFtZUlkUmVmIiwiaXNJbml0aWFsaXplZCIsInNldElzSW5pdGlhbGl6ZWQiLCJjdXJyZW50IiwiY29uc29sZSIsImxvZyIsInNjZW5lIiwiU2NlbmUiLCJiYWNrZ3JvdW5kIiwiQ29sb3IiLCJjYW1lcmEiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwicG9zaXRpb24iLCJzZXQiLCJsb29rQXQiLCJyZW5kZXJlciIsIldlYkdMUmVuZGVyZXIiLCJjYW52YXMiLCJhbnRpYWxpYXMiLCJhbHBoYSIsInNldFBpeGVsUmF0aW8iLCJNYXRoIiwibWluIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNldFNpemUiLCJhbWJpZW50TGlnaHQiLCJBbWJpZW50TGlnaHQiLCJhZGQiLCJkaXJlY3Rpb25hbExpZ2h0IiwiRGlyZWN0aW9uYWxMaWdodCIsInRlc3RHZW9tZXRyeSIsIkJveEdlb21ldHJ5IiwidGVzdE1hdGVyaWFsIiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJjb2xvciIsInRlc3RDdWJlIiwiTWVzaCIsImhhbmRsZVJlc2l6ZSIsIndpZHRoIiwiaGVpZ2h0IiwiYXNwZWN0IiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsImFkZEV2ZW50TGlzdGVuZXIiLCJhbmltYXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVuZGVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZGlzcG9zZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/flip-card-carousel/hooks/useThreeScene.ts\n"));

/***/ })

});